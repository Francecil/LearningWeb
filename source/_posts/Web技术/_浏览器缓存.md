
---
title: Web 缓存
date: 2019/12/29 00:00:00
categories: 大前端
tags: 
  - 缓存
---

# 前言

Web 缓存分为浏览器缓存和服务端缓存，本文主要描述的是浏览器缓存中的 HTTP 缓存


<!-- more -->

# 查看缓存文件

chrome 可以通过 `chrome://view-http-cache` 查看浏览器的缓存文件
> chrome 66 后就用不了了

火狐可以通过 `about:cache` 查看缓存文件列表

```
\User\xxx\AppData\Local\google\Chrome\User Data\Default\Cache\index 的文件内容
```

进入缓存文件详情页，可以看到缓存文件内容由三部分组成

- 资源请求地址
- 响应头
- 原文件的二进制内容

所以不能直接拿到缓存源文件，每次需要解码文件？

从如果删了缓存文件，是删了什么东西？index 内容修改以及 cache 中的文件？

会不会出现 index 中内容还在但是 cache 对应文件被删除的情况？

# 搭建测试环境

光看文档，理解肯定不够，还需要自己配置下环境，试试不同的请求响应对应的效果

TODO

# 强缓存

## Cache-Control 响应头

优先级比 `Expires` 高，且用的是相对时间，不需要担心客户端与服务端时间不一致带来的缓存失效问题

### max-age 

指定缓存的有效期

### s-maxage 

指定代理缓存（如cdn缓存）的有效期，优先级比 max-age 高

### no-cache 

不使用本地缓存

### no-store

禁用缓存

### public

可以被所有用户缓存，包括终端用户以及 CDN 等中间代理服务器

默认值

### private

仅能被终端用户缓存

## Expires 响应头

表示资源过期时间，以服务端时间为准


# 协商缓存

## Last-modified 响应头

表示服务端文件的最后修改时间

当缓存过期时，再次发起请求，会带个 `If-Modified-Since` 请求头，其值为之前返回的 `Last-modified` 响应头的值

服务端会去查询在该时间点后文件是否被修改，若被修改，返回新的资源, 200 响应以及 `Last-modified` 的新值；否则返回 304 响应，根据 Cache-Control 或 Expires 重新设置过期时间


## ETag 响应头

由于 `Last-modified` 只精确到秒，且如果内容没变但是最后修改时间变了，还是会当新资源请求

于是 http1.1 加了一个 `ETag` 响应头

其值为根据文件内容生成的 hash


当缓存过期时，再次发起请求，会带上 `If-None-Match` 请求头，其值为之前返回的 `ETag` 响应头的值

服务器会去该值和服务器文件的 hash 进行比对，若不同，返回新的资源和 200 响应以及 `ETag` 的新值；否则返回 304 响应，根据 Cache-Control 或 Expires 重新设置过期时间

**优先级比 `Last-modified` 高**

当两个同时存在时，先判断 ETag ，如果 hash 值没有变化，再去判断 `Last-modified` ，最终决定是否返回 304

# 总流程

借用参考文献1 中的某张图

![alloyteam](http://www.alloyteam.com/wp-content/uploads/2016/03/%E5%9B%BE%E7%89%8761.png)

# 用户行为


|用户操作  | 强缓存 | 协商缓存 |
|------------- | -------------|-------------|
地址栏回车  | 有效 |  有效 |
页面跳转   | 有效 |  有效 |
按刷新按钮   | 有效 | 有效  |
F5   | ? | 有效 |
ctrl + F5   | 无效 | 无效 |
Disable cache   | 无效 | 无效 |

网上有的说 F5 会导致强缓存无效，我在 Chrome 上测试，强缓存依旧有效

这里不知道是否是改了，说强缓存失效的是说会带上 If-Modified-Since 或 If-None-Match 请求头，然后 max-age=0 这样就会走协商缓存

ctrl + F5 会导致缓存失效的原因在于，请求在发起时会带上两个请求头
```
Cache-Control: no-cache
Pragma: no-cache
```
这样就不会走本地缓存，同时不会传 If-Modified-Since 和 If-None-Match ，因此会重新加载资源

# 常见问题

## 响应头未设置 cache-control 和 expires 还会强缓存么？

## 如何设置才能不缓存资源

## 通过 Expires 判断缓存过期，而本地时间比服务器时间快的话，会出现什么问题？ 

如果通过 Expires 判断缓存过期，而本地时间又比服务端快资源有效期以上，就会出现始终不能命中强缓存的情况

# 浏览器缓存中的其他缓存

读取某个 url 的资源，按照下面的过程 

（需要做个试验）

内存缓存
> preload 预加载的资源会存储在此处
> 当前页面已经加载过的资源会放在内存中，方便读取
> 但注意一点，如果资源设置了 no-store ，前面即使加载过这个资源，还是会继续加载（待确定）

Service Worker 缓存
> 有一套自己的缓存API

HTTP 缓存
> 上文提到的那个，根据请求响应等头部信息确定是否走缓存

HTTP2 Push 缓存
> 有一定是时效，chromium 中是五分钟
> 在命中缓存后，可能会在 HTTP 缓存中增加拷贝以及内存缓存增加引用


# 参考

1. [浅谈 Web 缓存](http://www.alloyteam.com/2016/03/discussion-on-web-caching/)
2. [http协商缓存VS强缓存](https://www.cnblogs.com/wonyun/p/5524617.html)
3. [Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)
4. [【译】关于四种缓存的故事](https://juejin.im/post/5aa5ddd4f265da23906ba592)