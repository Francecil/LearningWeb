
---
title: 浏览器缓存
date: 2019/12/29 00:00:00
categories: 大前端
tags: 
  - 缓存
---

# 前言

Web 缓存分为浏览器缓存和服务端缓存，本文主要描述的是浏览器缓存中的 HTTP 缓存


<!-- more -->

# 查看缓存文件

chrome 可以通过 `chrome://view-http-cache` 查看浏览器的缓存文件
> chrome 66 后就用不了了

pc 上的实际存储位置
```
\User\{user}\AppData\Local\google\Chrome\User Data\Default\Cache\index 的文件内容
```


火狐可以通过 `about:cache` 查看缓存文件列表



进入缓存文件详情页，可以看到缓存文件内容由三部分组成

- 资源请求地址
- 响应头
- 原文件的二进制内容

所以不能直接拿到缓存源文件，每次需要解码文件？

从如果删了缓存文件，是删了什么东西？index 内容修改以及 cache 中的文件？

会不会出现 index 中内容还在但是 cache 对应文件被删除的情况？

# 搭建测试环境

光看文档，理解肯定不够，还需要自己配置下环境，试试不同的请求响应对应的效果

TODO

# 强缓存

## Cache-Control 响应头

优先级比 `Expires` 高，且用的是相对时间，不需要担心客户端与服务端时间不一致带来的缓存失效问题

### max-age 

指定缓存的有效期

### s-maxage 

指定代理缓存（如cdn缓存）的有效期，优先级比 max-age 高

### no-cache 

不使用本地缓存

### no-store

禁用缓存

### public

可以被所有用户缓存，包括终端用户以及 CDN 等中间代理服务器

默认值

### private

仅能被终端用户缓存

## Expires 响应头

表示资源过期时间，以服务端时间为准


# 协商缓存

## Last-modified 响应头

表示服务端文件的最后修改时间

当缓存过期时，再次发起请求，会带个 `If-Modified-Since` 请求头，其值为之前返回的 `Last-modified` 响应头的值

服务端会去查询在该时间点后文件是否被修改，若被修改，返回新的资源, 200 响应以及 `Last-modified` 的新值；否则返回 304 响应，根据 Cache-Control 或 Expires 重新设置过期时间


## ETag 响应头

由于 `Last-modified` 只精确到秒，且如果内容没变但是最后修改时间变了，还是会当新资源请求

于是 http1.1 加了一个 `ETag` 响应头

其值为根据文件内容生成的 hash


当缓存过期时，再次发起请求，会带上 `If-None-Match` 请求头，其值为之前返回的 `ETag` 响应头的值

服务器会去该值和服务器文件的 hash 进行比对，若不同，返回新的资源和 200 响应以及 `ETag` 的新值；否则返回 304 响应，根据 Cache-Control 或 Expires 重新设置过期时间

**优先级比 `Last-modified` 高**

当两个同时存在时，先判断 ETag ，如果 hash 值没有变化，再去判断 `Last-modified` ，最终决定是否返回 304

# 总流程

借用参考文献1 中的某张图

![alloyteam](http://www.alloyteam.com/wp-content/uploads/2016/03/%E5%9B%BE%E7%89%8761.png)

# 用户行为


|用户操作  | 强缓存 | 协商缓存 |
|------------- | -------------|-------------|
前进后退   | 有效 |  有效 |
地址栏回车  | 无效 |  有效 |
按刷新按钮   | 无效 | 有效  |
F5   | 无效 | 有效 |
ctrl + F5   | 无效 | 无效 |
Disable cache   | 无效 | 无效 |

前四种针对的是文档请求，后两者针对的是所有资源的请求

强缓存失效的原因在于浏览器会在请求中带上`cache-control: max-age=0`

协商缓存失效的原因在于本该带上 `If-Modified-Since` 或 `If-None-Match` 请求头，但是浏览器没有带上，并带上以下两个请求头避免强缓存，因此会重新加载资源
```
Cache-Control: no-cache
Pragma: no-cache
```

前进后退是浏览器直接拿缓存页面，即使强缓存已经过期，所以即使断网了，后退还是能访问原来页面文档，参考自：https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.13

最后两种的区别在于，前者会走内存缓存（相同请求命中内存缓存，不会再发一条请求），后者什么缓存都不走；
> 放入内存缓存的是页面扫描加载的，脚步异步请求的不放内存中（？）

# 常见问题

## 请求头出现 Provisional headers are shown 的原因

1. 插件拦截
2. 命中本地缓存
3. 服务器超时
4. **跨域拦截**，最经常出现的情况，非同源的资源请求都会显示这个

## 响应头未设置 cache-control 和 expires 还会强缓存么？

## 如何设置才能不缓存资源

## 通过 Expires 判断缓存过期，而本地时间比服务器时间快的话，会出现什么问题？ 

如果通过 Expires 判断缓存过期，而本地时间又比服务端快资源有效期以上，就会出现始终不能命中强缓存的情况

# 浏览器缓存中的其他缓存

读取某个 url 的资源，按照下面的过程 

（需要做个试验）

内存缓存
> preload 预加载的资源会存储在此处
> 当前页面已经加载过的资源会放在内存中，方便读取
> 但注意一点，如果资源设置了 no-store ，前面即使加载过这个资源，还是会继续加载（待确定）

Service Worker 缓存
> 有一套自己的缓存API

HTTP 缓存
> 上文提到的那个，根据请求响应等头部信息确定是否走缓存

HTTP2 Push 缓存
> 有一定的时效，chromium 中是五分钟
> 在命中缓存后，可能会在 HTTP 缓存中增加拷贝以及内存缓存增加引用


# 参考

1. [浅谈 Web 缓存](http://www.alloyteam.com/2016/03/discussion-on-web-caching/)
2. [http协商缓存VS强缓存](https://www.cnblogs.com/wonyun/p/5524617.html)
3. [Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)
4. [【译】关于四种缓存的故事](https://juejin.im/post/5aa5ddd4f265da23906ba592)