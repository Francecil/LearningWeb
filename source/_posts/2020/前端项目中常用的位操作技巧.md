---
title: 前端项目中常用的位操作技巧
date: 2020-02-16 10:18:32
categories: 大前端
tags:
  - 位运算
  - JavaScript
---

## 前言

大部分例子引用自 [Bit Twiddling Hacks](https://graphics.stanford.edu/~seander/bithacks.html)

一些位操作优化的技巧在 js 中不一定能得到体现，本文仅展示一些自己在前端项目中用过且较常用的例子

某些例子比如交换，计算奇偶，计算最值的，使用位操作提升不大，但可读性变差了，本文不做记录

<!--more-->

## 1. 检测两个整数是否异号

本处例子中，0 与正数相当

```js
const isOppositeSign = (x, y) => (x ^ y) < 0
isOppositeSign(1, -2)  // true
isOppositeSign(1, 2)   // false
isOppositeSign(-0, -1) // true
```

## 2. 判断一个整数是否为 2 的幂

注意 0 不是 2 的幂，加上 `!!num` 判断

```js
const isPowerOf2 = (num) => !!num && (num & (num - 1)) === 0
isPowerOf2 (0) // false
isPowerOf2 (1) // true
isPowerOf2 (3) // false
```

## 3. 计算无符号整数的比特位中有多少个 1

常用于统计一组开关中状态为开的个数

### 原始方法

对 num 不断右移，每次判断最后一位是否为1，循环次数为 num 的比特位个数

```js
const countBits = (num) => {
  let res = 0
  for (; num; num >>= 1) {
    res += num & 1;
  }
  return res
}
countBits (4) // 1
```

### Brian Kernighan's way

每次清除一个最低的 1 的比特位，循环次数与 num 的比特位有多少个 1 相关

```js
const countBits = (num) => {
  let c = 0;
  for (; num; c++) {
    num &= num - 1; // 清除最低比特位
  }
  return c
}
countBits (5) // 2
```

## 4. 获取最高位 1 所在位置

得到一个索引值

```js
const getHighest1BitIndex = (num) => {
  let c = -1
  while (num) {
    num >>= 1
    c++
  }
  return c
}
```

同时可以用来计算一个整数以 2 为底的对数，其他拓展应用：

### 获取某个范围内最大的 2 的幂

```js
const hignBit = (num) => {
  let index = getHighest1BitIndex(num)
  return 1 << index
}
hignBit(14) // 8
hignBit(8) // 8
```

另一种解法

```js
const hignBit = (num) => {
  let res;
  while (num) {
    res = num
    num = num & (num - 1)
  }
  return res
}
hignBit(14) // 8
hignBit(8) // 8
```

## 5. 获取最低位 1 所在位置


利用 `n & -n` （又称 lowbit 函数）得到最低位 1 形成的数，然后不断右移得到索引值

```js
const lowBit = (num) => {
  return num & -num
}
const getLowest1BitIndex = (num) => {
  let n = lowBit(num)
  // return getHighest1BitIndex(n)
  let c = -1
  while (n) {
    n >>= 1
    c++
  }
  return c
}
```

树状数组中经常用到 lowbit


## 6. 交换指定位置与长度的比特序列

原始序列为 S, 将第 i 位(从右往左数，起始索引为1)开始，长度为 len 的序列与 第 j 位开始，长度为 len 的序列进行交换

举例，S = `0010111` i=1 len=3 j=5 交换后得到 `1110001`

```js
const swapIndividualBits = (num, i, j, len) => {
  let x = ((num >> i) ^ (num >> j)) & ((1 << len) - 1);
  return num ^ ((x << i) | (x << j));
}
swapIndividualBits (23,1,5,3) //113 23=>0010111(2) 113=>1110001(2)
```

常用于移动一组开关的位置


---

未完待续...

## 拓展阅读

1. [Bit Twiddling Hacks](https://graphics.stanford.edu/~seander/bithacks.html)
2. [Bit Hacks：关于一切位操作的魔法（上）](https://zhuanlan.zhihu.com/p/37014715)