## 前言

本文开始进入 Vue 的核心部分：响应式处理

在看源码之前，我们先试着实现一个响应式系统

## 响应式原理

响应式的关键在于数据如何与视图进行绑定

假设我们有一个对象 `data:{name:""}` ，以及一个 input 节点，我们如何做到两者的绑定？

我们知道，监测对象数据变化可以用 `Object.defineProperty` ，监测 input 节点数据变化可以通过监听事件。因此我们可以很快的写出这样的代码
```html
<!DOCTYPE html>
<html>

<head>
</head>

<body>
  <input id="input" />
</body>
<script>
  // 初始化
  var data = {
    name: "test"
  }
  var input = document.getElementById("input")
  input.value = data.name

  // 双向绑定
  input.addEventListener("input", function (e) {
    // input 数据变化 data 跟着变化
    data.name = e.target.value
  })
  function defineReactive(obj, key, val) {
    Object.defineProperty(obj, key, {
      get() {
        return val
      },
      set(newVal) {
        val = newVal
        // data 变化 input 跟着变化
        input.value = val
      }
    })
  }
  defineReactive(data, "name", data.name)

</script>

</html>
```
控制台上设置 name, input 会进行更新, 反过来一样。

**实现的关键在于闭包， get/set 实际是对闭包变量 val 进行操作**。

但是发现没有，data 数据变更和 dom 更新的处理耦合在一起了，set name 方法一开始就确定好了，但是我们不能确定所有依赖 name 的项。比如说有另一个 input 或者 compute 属性也依赖于 `data.name` ，那 set name 方法就不能直接处理了。

因此需要采用发布-订阅设计模式，引入依赖收集，大概这样：

1. 定义 `data.name` 的 get/set , 并在其中创建一个发布者 dep
2. 创建订阅者 watcher , 更新方法属于被动调用，调用时会进行 dom 更新, 如 input 的值进行更新
3. 设置 `Dep.target = watcher`
4. 触发 `data.name` 的 get, 此时 Dep.target 有值，即 watcher 会加入到 dep 的订阅者列表中，同时 watcher 也添加了发布者 dep
5. 当 `data.name` 的 set 方法被调用时，会通知 watcher 去更新 dom

即数据变动时，发布者通知其订阅者进行更新。

可能你会说，这不应该是叫观察者模式么？的确，如果订阅者直接进行更新那就是观察者模式，但

```js

```

从xxx 层面上看观察者模式，从 xxx 层面看是发布订阅

## data 源码解析

我们带着这样几个问题看源码：
1. 重复订阅的问题


至此， data 源码解析完毕，总结如下

## 实现一个相对完整的响应式系统

