## 前言

长列表也就虚拟列表，是一种大数据量下通过只渲染可见节点避免页面卡顿的优化方案

前端比较有名的有两个项目：
- react-window
- vue-virtual-scroller

本文将对其源码进行解析，分析实现原理和并进行评估，最终实现一套通用的长列表组件

主要评估几点：
1. 性能：是否产生回流，渲染节点策略，优化策略
2. 功能点：自定义高度，自适应高度
3. 拓展性：方便集成到 Tree 等其他组件上

## 长列表入门

本章将通过一个最简单的例子来开启长列表的入门

xxx

我们还需要做的事有：
xxx

下面我们来看看其他开源库都怎么做的

## vue-virtual-scroller

[项目地址](https://github.com/Akryum/vue-virtual-scroller)



### 解析



transform



## react-window

absolute+top

## 开源库比对分析

## 优化策略分析

### 定义高度方法--处理方式1

初次滚动，cache 已滚动过的元素的偏移和索引， O(n)

总高度 = 已滚动索引（lastMeasuredIndex）的偏移 + 剩余元素 * 默认值

向上滚动，值都计算过了，二分查找即可 O(logn)

向下滚动，做个遍历，并 cache 元素的偏移和索引 O(n)

此时再向上滚动，若在已滚动索引的偏移量内，则采用二分 O(logn) ，若不在，从已滚动索引开始继续顺序查询并cache

观察 lastMeasuredIndex ，若改变，总高度跟着变

[demo](https://jsfiddle.net/furybean/teg2ur1b/1/)

- 缺点：做不了自适应高度
- 缺点2：前面的滚动较耗时间，把没用到的也计算进去了



### 定义高度方法--处理方式2

初始，总高度 = 元素个数 * 默认值

定义一个计算缓存，存放已计算的元素高度

滚动到对应位置，通过 itemSizeGetter 获取元素高度，并将取得的高度与默认值之间的差更新到总高度上，并更新对应项的缓存

查找第一项，采用顺序查找，有缓存的拿缓存，没有的用默认值,每次都是 O(n) 

缺点：查找效率太低

### 定义高度方法--处理方式3

初始，定义了 positions 数组，内容为各元素默认偏移量（top,bottom），取值索引*默认高度

总高度 = positions 最后一项的 bottom

滚动到对应位置，通过 itemSizeGetter 获取元素高度，并将差异值更新到其后所有 positions 项的 top,bottom ，时间复杂度 O(n*m) 

滚动时，查找第一项，根据 positions 采用二分，O(logn)

缺点：更新 positions 较为耗时

### 自适应高度处理方式


初始，定义了 positions 数组，内容为各元素默认偏移量（top,bottom），取值索引*默认高度

总高度 = positions 最后一项的 bottom

滚动到对应位置，渲染的个数采用预估值+缓冲值（由于item实际高度初始不确定，需要多计算几项用于填满空间避免白屏），先用 positions 计算一次初始偏移量

渲染完列表item后计算这些item 实际高度和偏移，更新 positions 数组，更新页面总高度，并更新偏移量
> 这个计算在vue 中可以放在 update 的 nextTick 中进行 \
> 更新偏移量时，顺序更新该项后的每一项的偏移量，时间复杂度 O(n*m) m为 item 个数，n 为 item后的元素个数。这里可以做个剪枝，高度不变就不会向后 \
> 更新页面总高度就还是取 positions 最后一项的 bottom

滚动时，查找第一项，根据 positions 采用二分，O(logn)

[demo](https://codesandbox.io/s/virtuallist-3-i3h9v)

- 缺点1：会出现拉滚动条，拉着拉着跟不上（因为偏移位置更新了）的情况，不过影响不是很大
- 缺点2：更新偏移量，时间复杂度较高，且基本每次滚动都要做这个更新

### 树状数组优化

前面两种的处理方式，查询效率高，但是更新效率太低。

数据模型大概是这样的：

已知长度为 len 的整形数组 nums ，有两种操作：
1. 更新数组中某项的值
2. 查询前 n 项的总和， 1<= n <= len

有什么方式能做到两种操作都在时间复杂度 log(n) ? 可以采用树状数组实现

树状数组原理可以参考 xxx



### 可视区域的列表高 

可视区域的列表高度，一般不变，没必要每次都通过 `$el.clientHeight` 获取（会造成回流），在 resize 时再改变

## 综合实现


Item 单独抽离，用 slot ，方便用户自定义


## 展望

ResizeObserver 

## 参考

1. [virtual-list-demo](https://github.com/ChuChencheng/virtual-list-demo)
2. [「前端进阶」高性能渲染十万条数据(虚拟列表)](https://www.jianshu.com/p/15cc08ec366a)
3. [再谈前端虚拟列表的实现](https://zhuanlan.zhihu.com/p/34585166)